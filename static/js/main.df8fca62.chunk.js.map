{"version":3,"sources":["dmAppointmentPlus.ts","index.tsx"],"names":["send","actions","cancel","say","text","_context","type","value","resolveYes","recResult","grammar","affirmation","resolveNo","getDefaultRecogEvents","help_msg","target","cond","context","getHelpAction","getDefaultMaxSpeechEvents","assign","prompts","getDefaultStates","prompt","reprompt","nomatch","initial","states","entry","on","ENDSPEECH","ask","delay","id","person","day","time","dmMachine","act","hist","history","init","CLICK","welcome","who","RECOGNISED","MAXSPEECH","duration","confirmDay","confirmTime","final","stop","always","help","inspect","url","iframe","machine","Machine","dm","asrtts","idle","LISTEN","SPEAK","event","ttsAgenda","recognising","exit","ASRRESULT","progress","match","speaking","recLogResult","console","log","test","logIntent","nluData","intent","name","ReactiveButton","props","state","matches","className","style","animation","App","useSpeechSynthesis","onEnd","speak","useSpeechRecognition","onResult","result","listen","listening","useMachine","devTools","recStart","asEffect","interimResults","continuous","recStop","changeColour","document","body","background","ttsStart","effect","ttsCancel","current","onClick","origin","location","nluRequest","fetch","Request","proxyurl","method","headers","then","data","json","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.df8fca62.chunk.js","sourcesContent":["import { MachineConfig, actions, Action, assign } from \"xstate\";\nconst { send, cancel } = actions;\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction listen(): Action<SDSContext, SDSEvent> {\n    return send('LISTEN')\n}\n\nfunction resolveYes(recResult: string): boolean {\n    return recResult === 'yes' || (grammar[recResult] && grammar[recResult].affirmation == \"yes\")\n}\n\nfunction resolveNo(recResult: string): boolean {\n    return recResult === 'no' || (grammar[recResult] && grammar[recResult].affirmation == \"no\")\n}\n\nfunction getDefaultRecogEvents(help_msg: string) {\n    return [\n        { target: '#appointment.stop', cond: (context: SDSContext) => context.recResult === 'stop' },\n        {\n            cond: (context: SDSContext) => context.recResult === 'help',\n            actions: getHelpAction(help_msg),\n            target: '#appointment.help'\n        },\n        { target: \".nomatch\" }\n    ]\n}\n\nfunction getDefaultMaxSpeechEvents() {\n    return [\n        {\n            actions: getRepromptAction(),\n            cond: (context: SDSContext) => !context.prompts || context.prompts < 3,\n            target: \".reprompt\"\n        },\n        {\n            actions: getClearRepromptAction(),\n            cond: (context: SDSContext) => context.prompts >= 3,\n            target: \"init\"\n        }\n    ]\n}\n\nfunction getDefaultStates(prompt: Action<SDSContext, SDSEvent>, reprompt: Action<SDSContext, SDSEvent>,\n    nomatch: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: 'prompt',\n        states: {\n            prompt: {\n                entry: prompt,\n                on: { ENDSPEECH: \"ask\" }\n            },\n            reprompt: {\n                entry: reprompt,\n                on: { ENDSPEECH: \"ask\" }\n            },\n            ask: {\n                entry: [listen(), send('MAXSPEECH', { delay: 3000, id: 'maxsp' })]\n            },\n            nomatch: {\n                entry: say(nomatch),\n                on: { ENDSPEECH: \"reprompt\" }\n            }\n        }\n    })\n}\n\n// functions for getting assign-actions, my editor gives an error when the result is \n// directly in the actions: ... part\n\nfunction getHelpAction(help_msg: string): any {\n    return assign((context) => { return { help_msg: help_msg } });\n}\n\nfunction getRepromptAction(): any {\n    return assign((context: SDSContext) => { return { prompts: context.prompts ? context.prompts + 1 : 1 } });\n}\n\nfunction getClearRepromptAction(): any {\n    return assign((context: SDSContext) => { return { prompts: 0 } });\n}\n\nconst grammar: { [index: string]: { person?: string, day?: string, time?: string, affirmation?: string } } = {\n    \"Anna\": { person: \"Anna Appleseed\" },\n    \"John\": { person: \"John Appleseed\" },\n    \"Patricia\": { person: \"Patricia G\" },\n    \"Mary\": { person: \"Mary\" },\n    \"Bob\": { person: \"Bob the Builder\" },\n    \"Mike\": { person: \"Michael\" },\n    \"on Friday\": { day: \"Friday\" },\n    \"tomorrow\": { day: \"tomorrow\" },\n    \"Monday\": { day: \"Monday\" },\n    \"10\": { time: \"10:00\" },\n    \"at ten\": { time: \"10:00\" },\n    \"at 10\": { time: \"10:00\" },\n    \"eleven\": { time: \"11:00\" },\n    \"at noon\": { time: \"12:00\" },\n    \"at 3\": { time: \"15:00\" },\n    \"of course\": { affirmation: \"yes\" },\n    \"absolutely\": { affirmation: \"yes\" },\n    \"no way\": { affirmation: \"no\" },\n    \"not really\": { affirmation: \"no\" }\n}\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    id: 'appointment',\n    initial: 'act',\n    states: {\n        act: {\n            initial: 'init',\n            // NOTE use welcome as initial state if machine was imported in dmPrompt-machine\n            // currently dmAppointmentPlus is the \"main\" machine (imported in idex.tsx)\n            // initial: 'welcome',\n            states: {\n                hist: { type: 'history', history: 'deep' },\n                init: {\n                    on: {\n                        CLICK: 'welcome'\n                    }\n                },\n                welcome: {\n                    initial: \"prompt\",\n                    on: { ENDSPEECH: \"who\" },\n                    states: {\n                        prompt: { entry: say(\"Let's create an appointment\") }\n                    }\n                },\n                who: {\n                    on: {\n                        RECOGNISED: [{\n                            cond: (context) => \"person\" in (grammar[context.recResult] || {}),\n                            actions: assign((context) => { return { person: grammar[context.recResult].person } }),\n                            target: \"day\"\n                        },\n                        ...getDefaultRecogEvents(\"Tell me the name of the person.\")],\n                        MAXSPEECH: [...getDefaultMaxSpeechEvents()]\n                    },\n                    ...getDefaultStates(say(\"Who are you meeting with?\"),\n                        say(\"Can you tell me who you are meeting with?\"),\n                        \"Sorry, I don't know them.\")\n                },\n                day: {\n                    on: {\n                        RECOGNISED: [{\n                            cond: (context) => \"day\" in (grammar[context.recResult] || {}),\n                            actions: assign((context) => { return { day: grammar[context.recResult].day } }),\n                            target: \"duration\"\n                        },\n                        ...getDefaultRecogEvents(\"Tell me the day of the meeting.\")],\n                        MAXSPEECH: [...getDefaultMaxSpeechEvents()]\n                    },\n                    ...getDefaultStates(send((context) => ({\n                        type: \"SPEAK\",\n                        value: `OK. ${context.person}. On which day is your meeting?`\n                    })),\n                        say(\"What day do you have your meeting?\"),\n                        \"Can you repeat that?\")\n                },\n                duration: {\n                    on: {\n                        RECOGNISED: [\n                            { target: 'confirmDay', cond: (context) => resolveYes(context.recResult) },\n                            { target: 'time', cond: (context) => resolveNo(context.recResult) },\n                            ...getDefaultRecogEvents(\"Tell me yes or no.\"),\n                        ],\n                        MAXSPEECH: [...getDefaultMaxSpeechEvents()]\n                    },\n                    ...getDefaultStates(say(\"Will it take the whole day?\"),\n                        say(\"Is your meeting going to last the entire day?\"),\n                        \"I did not catch that.\")\n                },\n                time: {\n                    on: {\n                        RECOGNISED: [{\n                            cond: (context) => \"time\" in (grammar[context.recResult] || {}),\n                            actions: assign((context) => { return { time: grammar[context.recResult].time } }),\n                            target: \"confirmTime\",\n                        },\n                        ...getDefaultRecogEvents(\"Tell me the time of your meeting.\")],\n                        MAXSPEECH: [...getDefaultMaxSpeechEvents()]\n                    },\n                    ...getDefaultStates(say(\"What time is your meeting?\"),\n                        say(\"When does your meeting start?\"),\n                        \"Can you repeat that?\")\n                },\n                confirmDay: {\n                    on: {\n                        RECOGNISED: [\n                            { target: 'final', cond: (context) => resolveYes(context.recResult) },\n                            { target: 'welcome', cond: (context) => resolveNo(context.recResult) },\n                            ...getDefaultRecogEvents(\"Tell me yes or no.\")\n                        ],\n                        MAXSPEECH: [...getDefaultMaxSpeechEvents()]\n                    },\n                    ...getDefaultStates(\n                        send((context) => ({\n                            type: \"SPEAK\",\n                            value: `Do you want me to create an appointment with ${context.person} on ${context.day} for the whole day?`\n                        })),\n                        send((context) => ({\n                            type: \"SPEAK\",\n                            value: `You are meeting with ${context.person} on ${context.day} for the whole day. Is that correct?`\n                        })),\n                        \"Yes or no?\")\n                },\n                confirmTime: {\n                    on: {\n                        RECOGNISED: [\n                            { target: 'final', cond: (context) => resolveYes(context.recResult) },\n                            { target: 'welcome', cond: (context) => resolveNo(context.recResult) },\n                            ...getDefaultRecogEvents(\"Tell me yes or no.\")\n                        ],\n                        MAXSPEECH: [...getDefaultMaxSpeechEvents()]\n                    },\n                    ...getDefaultStates(\n                        send((context) => ({\n                            type: \"SPEAK\",\n                            value: `Do you want me to create an appointment with ${context.person} on ${context.day} at ${context.time}?`\n                        })),\n                        send((context) => ({\n                            type: \"SPEAK\",\n                            value: `You are meeting with ${context.person} on ${context.day} at ${context.time}. Is that correct?`\n                        })),\n                        \"Yes or no?\")\n                },\n                final: {\n                    initial: \"prompt\",\n                    on: { ENDSPEECH: \"init\" },\n                    states: {\n                        prompt: {\n                            entry: say(\"Your appointment has been created!\")\n                        }\n                    }\n                },\n            }\n        },\n        stop: {\n            entry: say(\"Ok\"),\n            always: 'act'\n        },\n        help: {\n            entry: send((context) => ({\n                type: \"SPEAK\",\n                value: `${context.help_msg}`\n            })),\n            on: { ENDSPEECH: \"act.hist\" }\n        }\n    }\n})\n","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Machine, assign, actions, State } from \"xstate\";\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\nimport { dmMachine } from \"./dmAppointmentPlus\";\nconst { send, cancel } = actions;\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\nimport { useSpeechSynthesis, useSpeechRecognition } from 'react-speech-kit';\n\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    states: {\n        dm: {\n            ...dmMachine\n        },\n        asrtts: {\n            initial: 'idle',\n            states: {\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\n                        }\n                    }\n                },\n                recognising: {\n                    initial: 'progress',\n                    entry: 'recStart',\n                    exit: 'recStop',\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => { return { recResult: event.value } })],\n                            target: '.match'\n                        },\n                        RECOGNISED: {\n                            actions: [cancel('maxsp'), assign((context: SDSContext) => { return { prompts: 0 } })],\n                            target: 'idle'\n                        },\n                        MAXSPEECH: 'idle'\n                    },\n                    states: {\n                        progress: {\n                        },\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                    }\n                },\n                speaking: {\n                    entry: 'ttsStart',\n                    on: {\n                        ENDSPEECH: 'idle',\n                    }\n                }\n            }\n        }\n    },\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('<< ASR: ' + context.recResult);\n            },\n            test: () => {\n                console.log('test')\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    switch (true) {\n        case props.state.matches({ asrtts: 'recognising' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"glowing 20s linear\" }} {...props}>\n                    Listening...\n                </button>\n            );\n        case props.state.matches({ asrtts: 'speaking' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"bordering 1s infinite\" }} {...props}>\n                    Speaking...\n                </button>\n            );\n        default:\n            return (\n                <button type=\"button\" className=\"glow-on-hover\" {...props}>\n                    Click to start\n                </button >\n            );\n    }\n}\n\nfunction App() {\n    const { speak, cancel, speaking } = useSpeechSynthesis({\n        onEnd: () => {\n            send('ENDSPEECH');\n        },\n    });\n    const { listen, listening, stop } = useSpeechRecognition({\n        onResult: (result: any) => {\n            send({ type: \"ASRRESULT\", value: result });\n        },\n    });\n    const [current, send, service] = useMachine(machine, {\n        devTools: true,\n        actions: {\n            recStart: asEffect(() => {\n                console.log('Ready to receive a command.');\n                listen({\n                    interimResults: false,\n                    continuous: true\n                });\n            }),\n            recStop: asEffect(() => {\n                console.log('Recognition stopped.');\n                stop()\n            }),\n            changeColour: asEffect((context) => {\n                console.log('Repainting...');\n                document.body.style.background = context.recResult;\n            }),\n            ttsStart: asEffect((context, effect) => {\n                console.log('Speaking...');\n                speak({ text: context.ttsAgenda })\n            }),\n            ttsCancel: asEffect((context, effect) => {\n                console.log('TTS STOP...');\n                cancel()\n            })\n            /* speak: asEffect((context) => {\n         * console.log('Speaking...');\n             *     speak({text: context.ttsAgenda })\n             * } */\n        }\n    });\n\n\n    return (\n        <div className=\"App\">\n            <ReactiveButton state={current} onClick={() => send('CLICK')} />\n        </div>\n    )\n};\n\n\n\n/* RASA API\n *  */\nconst proxyurl = \"https://cors-anywhere.herokuapp.com/\";\nconst rasaurl = 'https://gussuvmi-rasa-nlu.herokuapp.com/model/parse';\nconst origin = location.origin;\n\nexport const nluRequest = (text: string) =>\n    fetch(new Request(proxyurl + rasaurl, {\n        method: 'POST',\n        headers: {\n            'Origin': origin //'http://maraev.me'\n        }, // only required with proxy\n        body: `{\"text\": \"${text}\"}`\n    }))\n        .then(data => data.json());\n\n\n\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App />,\n    rootElement);\n"],"sourceRoot":""}